from typing import Any, Generator

import numpy as np
from _typeshed import Incomplete
from numpy import typing as npt

class Maze:
    maze: Incomplete
    algorithm: Incomplete
    pathfinder: Incomplete
    have_value: bool
    start: Incomplete
    end: Incomplete
    def __init__(
        self,
        *nb_cells_by_sides: int,
        start: tuple[int, int] | None = None,
        end: tuple[int, int] | None = None,
    ) -> None: ...
    def __iter__(self) -> Generator[tuple[tuple[int, int], np.uint16], None, None]: ...
    was_scuplted: bool
    def sculpt_grid(self) -> None: ...
    def set_values(self) -> None: ...
    def set_start_end(self) -> None: ...
    def remove_walls(self) -> None: ...
    def kruskal(self) -> None: ...
    def randomized_depth_first_search(self, start: tuple[int, int] | None = None) -> None: ...
    def prim(self, start: tuple[int, int] | None = None) -> None: ...
    def hunt_and_kill(self, start: tuple[int, int] | None = None) -> None: ...
    def eller(
        self, probability_carve_horizontally: float = 0.5, probability_carve_vertically: float = 0.5
    ) -> None: ...
    def iterative_division(self) -> None: ...
    def binary_tree(
        self, user_biais: int = 0, probability_carve_vertically: float = 0.5
    ) -> None: ...
    def sidewinder(self, probability_carve_north: float = 0.5) -> None: ...
    def growing_tree(
        self,
        start: tuple[int, int] | None = None,
        mode: str = "newest",
        probability: float | None = None,
    ) -> None: ...
    def aldous_broder(self, start: tuple[int, int] | None = None) -> None: ...
    def wilson(self) -> None: ...
    def origin_shift(self, nb_iter: int = 0) -> None: ...
    def merge_values(
        self, wall_coordinate: tuple[int, int] | list[int], values: tuple[int, int]
    ) -> None: ...
    def make_imperfect_maze(self, mode: tuple[str, int | float]) -> None: ...
    def generate_image(self, filename: str | None = None) -> None: ...
    def save_maze(self, filename: str) -> None: ...
    def load_maze(self, file: str) -> None: ...

def cells_to_shape(*nb_cells_by_side: int) -> tuple[int, int]: ...
def verify_coordinates(
    coordinates: Any | tuple[Any, ...], shape: tuple[int, int]
) -> tuple[int, int]: ...
def verify_shape(shape: Any | tuple[Any, ...]) -> bool: ...
def verify_values_maze(maze: npt.NDArray[np.uint]) -> bool: ...
def get_breakable_walls(self) -> list[tuple[int, int]]: ...
def get_neighbors(
    self,
    cell: tuple[int, int],
    directions: tuple[tuple[int, int], ...] | None = None,
    return_visited: bool = False,
) -> list[tuple[tuple[int, int], tuple[int, int]]]: ...
def get_random_cell(shape: tuple[int, int]) -> tuple[int, int]: ...
def get_connection(self, index: tuple[int, int]) -> tuple[tuple[int, int], tuple[int, int]]: ...
def select_cell_by_mode(
    cells: list[tuple[int, int]], mode: str, probability: float
) -> tuple[tuple[int, int], int]: ...
def load_object(file_path: str) -> Maze: ...
def curious_maze() -> Maze: ...
