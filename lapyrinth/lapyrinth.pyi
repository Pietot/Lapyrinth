from typing import Any, Generator

import numpy as np
from _typeshed import Incomplete
from numpy import typing as npt

class Maze:
    maze: Incomplete
    algorithm: Incomplete
    pathfinder: Incomplete
    have_value: bool
    start: Incomplete
    end: Incomplete
    def __init__(
        self,
        *nb_cells_by_sides: int,
        start: tuple[int, int] | None = None,
        end: tuple[int, int] | None = None,
    ) -> None: ...
    def __iter__(self) -> Generator[tuple[tuple[int, int], np.uint16], None, None]: ...
    was_scuplted: bool
    def sculpt_grid(self) -> None: ...
    def set_values(self) -> None: ...
    def set_random_values(self) -> None: ...
    def set_start_end(self) -> None: ...
    def remove_walls(self) -> None: ...
    def kruskal(self) -> None: ...
    def randomized_depth_first_search(self, start: tuple[int, int] | None = None) -> None: ...
    def simplified_prim(self, start: tuple[int, int] | None = None) -> None: ...
    def true_prim(self, start: tuple[int, int] | None = None) -> None: ...
    def hunt_and_kill(self, start: tuple[int, int] | None = None) -> None: ...
    def eller(
        self, probability_carve_horizontally: float = 0.5, probability_carve_vertically: float = 0.5
    ) -> None: ...
    def iterative_division(self) -> None: ...
    def binary_tree(
        self, user_biais: int = 0, probability_carve_vertically: float = 0.5
    ) -> None: ...
    def sidewinder(self, probability_carve_north: float = 0.5) -> None: ...
    def growing_tree(
        self,
        start: tuple[int, int] | None = None,
        mode: str = "newest",
        probability: float | None = None,
    ) -> None: ...
    def aldous_broder(self, start: tuple[int, int] | None = None) -> None: ...
    def wilson(self) -> None: ...
    def origin_shift(self, nb_iter: int = 0) -> None: ...
    def merge_values(
        self, wall_coordinate: tuple[int, int] | list[int], values: tuple[int, int]
    ) -> None: ...
    def make_imperfect_maze(self, mode: tuple[str, int | float]) -> None: ...
    def generate_image(self, filename: str | None = None) -> None: ...
    def save(self, filename: str | None = None) -> None: ...
    @staticmethod
    def get_breakable_walls(maze: npt.NDArray[np.uint16]) -> list[tuple[int, int]]: ...
    @staticmethod
    def get_neighbors(
        maze: npt.NDArray[np.uint16],
        cell: tuple[int, int],
        directions: tuple[tuple[int, int], ...] | None = None,
        return_visited: bool = False,
    ) -> list[tuple[tuple[int, int], tuple[int, int]]]: ...
    @staticmethod
    def get_connection(
        maze: npt.NDArray[np.uint16], index: tuple[int, int]
    ) -> tuple[tuple[int, int], tuple[int, int]]: ...
    @staticmethod
    def verify_shape(shape: Any | tuple[Any, ...]) -> bool: ...
    @staticmethod
    def verify_maze_values(maze: npt.NDArray[np.uint]) -> bool: ...
    @staticmethod
    def get_random_cell(shape: tuple[int, int]) -> tuple[int, int]: ...
    @staticmethod
    def select_cell_by_mode(
        cells: list[tuple[int, int]], mode: str, probability: float
    ) -> tuple[tuple[int, int], int]: ...
    @classmethod
    def load(cls, file_path: str) -> Maze: ...
    @classmethod
    def curious_maze(cls) -> Maze: ...

def cells_to_shape(*nb_cells_by_side: int) -> tuple[int, int]: ...
def verify_coordinates(
    coordinates: Any | tuple[Any, ...], shape: tuple[int, int]
) -> tuple[int, int]: ...
